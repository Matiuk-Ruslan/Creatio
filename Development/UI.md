# UI

## Клиентская схема

Маркерные комментарии необходимо использовать в исходном коде схемы для свойств `diff`, `modules`, `details` и `businessRules`.

* `entitySchemaName` - имя схемы объекта, который используется текущей клиентской схемой
* `attributes` - конфигурационный объект, который содержит атрибуты схемы. _Определяем дополнительный свойства и виртуальные колонки_
* `modules` - конфигурационный объект, который содержит модули схемы
* `messages` - конфигурационный объект, который содержит сообщения схемы
* `mixins` - конфигурационный объект, который содержит объявление миксинов
* `details` - свойство используется для загрузки детали на страницу
* `businessRules` - конфигурационный объект, который содержит бизнес-правила схемы, созданные или измененные мастером разделов или мастером деталей
* `methods` - конфигурационный объект, который содержит методы схемы
* `dataModels` - используется в бизнес-процессах для преднастроеных страниц
* `diff` - массив конфигурационных объектов, который содержит описание представления схемы

**Миксин** — это класс-примесь, предназначенный для расширения функциональности других классов. В **JavaScript** нет множественного наследования, а наличие миксинов позволяет расширить функциональность схемы без дублирования логики, часто используемой в методах схемы. В разных клиентских схемах приложения **Creatio** может использоваться один и тот же набор действий. Чтобы не дублировать код в каждой схеме, необходимо создать миксин. Особенность миксинов в сравнении с другими модулями, подключаемыми в список зависимостей, — способ вызова методов из схемы модуля (к методам миксина можно обращаться напрямую, как к методам схемы). Для реализации миксинов необходимо использовать свойство `mixins`.

---

### **Правила объявления свойства `diff`:**

`diff` — массив конфигурационных объектов, который содержит описание представления схемы

* `name` - мастер называет компомненты или мы можем ее переопределить
* `operation`
  * `insert` - добавление
  * `merge` - изменение/переопределение
  * `move` - перемещение
* `values`
  * `layout`
    * `colSpan` — количество занимаемых столбцов
    * `rowSpan` — количество занимаемых строк. Значение по умолчанию `1`
    * `column` — индекс левого столбца
    * `row` — индекс верхней строки
    * `layoutName` - имя контейнера где находится элемент
  * `bindTo` - указывает на связи между атрибутом модели представления и свойством объекта представления
  * `enabled` - `true`: открыт для редактирования, `false`: закрыт для редактирования
  * `visible` - `true`: Отображаются объект, `false`: Не отображаются объект
* `parentName` - имя родительского элемента
* `propertyName` - свойство родительского элемента
* `index` - свойство которое помогает с табуляцией внутри контейнера

---

### **Правила объявления свойства `attributes`:**

`attributes` — конфигурационный объект, который содержит атрибуты схемы. Расширение view модели

* `Name_attribute`
  * `dataValueType` - переопределение типа данных
  * `dependencies` - содержит массив конфигурационных объектов
    * `сolumns` - имя метода-обработчика, который вызывается при изменении значения хотя бы одной из перечисленных колонок
    * `methodName` - массив имен колонок, от значений которых зависит значение текущей колонки
  * `columns: ["Name", "JobTitle"]` - какие свойства проверяем
  * `methodName: "showInf"` - какой метод вызываем на свойствах указаных в `columns`
  * `lookupListConfig`
    * `columns: ["Name", "BillingInfo"]`

---

Методы:

```JS
init: function() {
  this.callParent(arguments);
}

onEntityInitialized: function() {
  this.callParent(arguments); // вызывает родительскую реализацию этого метода
}
```

`this.$Id` - новый вариант чтения
`this.get("Id")` - старый вариант чтения
`this.set("Name","Kirill")` - присвоение значения свойству

---

Используется MVVM патерн на UI.

---



```JS
showInf: function() {
  var a = arguments;
  this.showInformatuinDialog("Something Changed")
}
```

## Заметки

* Особое место среди сторонних модулей занимает фреймворк ExtJS, который используется для объявления классов в ядре в клиентских модулях. Для доступа к функциональности фреймворка необходимо добавить в модуль зависимость от модуля `ext-base`
* Чтобы получить доступ к функциональности sandbox, разрабатываемый модуль должен импортировать в качестве зависимости модуль `sandbox`
* Чтобы получить доступ к функциональности ядра, разрабатываемый модуль должен импортировать в качестве зависимости модуль `terrasoft`

### В Creatio можно выделить несколько разновидностей клиентских модулей:

* **Стандартные**
  * Стандартный модуль содержит в себе функциональность системы, которую модуль может выполнять самостоятельно. Однако, при этом модуль не может отображать результаты своей работы в пользовательском интерфейсе. Исходные коды стандартных модулей, создаваемых сторонними разработчиками, должны размещаться в конфигурационных схемах типа “Модуль”, размещенных в пакетах Creatio.
  * Стандартный клиентский модуль может содержать в себе метод `init()`, который реализует логику, выполняемую при загрузке модуля. Клиентское ядро, обнаруживая при загрузке модуля такой метод, автоматически вызывает его самым первым. Как правило, в методе `init()` выполняется подписка на события других модулей и инициализация значений.
* **Утилитные**
  * Утилитный модуль отличается от стандартного тем, что в нем реализована функциональность, которая используется только в других модулях и не применима вне их контекста. Например, в процессе разработки вспомогательные и служебные методы общего назначения можно группировать в отдельные утилитные модули и затем импортировать их в те модули, в которых необходима эта функциональность. Исходные коды разрабатываемых утилитных модулей также должны размещаться в конфигурационных схемах типа “Модуль”. Последовательность их создания аналогична последовательности создания стандартных модулей.
* **Визуальные**
  * К визуальным относят модули, которые могут отображать результаты в интерфейсе Creatio. Такие модули, кроме метода `init()`, должны обязательно содержать также методы `render()` и `destroy()`.
  * Метод `render()` создает экземпляр представления (как правило, контейнер, содержащий коллекцию элементов управления) и добавляет его в Document Object Model (DOM) страницы приложения. Логика вызова метода `render()` у объекта модуля описана на уровне ядра приложения. Если модуль визуальный, т.е. содержит метод `render()`, то выгрузить представление из DOM, не реализовав логику выгрузки в методе `destroy()`, не удастся. Таким образом, представление модуля будет оставаться в DOM страницы. Исходные коды разрабатываемых визуальных модулей должны размещаться в конфигурационных схемах типа “Модуль”. Последовательность их создания аналогична последовательности создания стандартных модулей.

### РЕАЛИЗАЦИЯ ШАБЛОНА ПРОЕКТИРОВАНИЯ MVVM В CREATIO

* Модель (Model)
  * Model в Creatio представлена серверной ORM-моделью `Entity` (см. “Работа с сущностью базы данных. Класс `Entity”`). Создание новых типов объектов Model (наследников `Entity`) выполняется в разделе [Конфигурация] (см “Создание схемы объекта”)
  * Получить нужный `Entity`-объект на клиентской стороне можно, используя, например, запросы клиентского `EntitySchemaQuery` (см. “CRUD-операции в конфигурационных схемах”)
* Представление (View)
  * В роли View в Creatio выступают элементы пользовательского интерфейса
  * Все элементы интерфеса Creatio являются наследниками абстрактного класса `Terrasoft.Component`, который реализует базовую логику графических элементов управления. В классе `Terrasoft.Component` используется миксин `bindable`, реализующий механизм связывания данных в соответствии с шаблоном MVVM
  * Чтобы связать данные, предоставляемые ViewModel, с соответствующим View в Creatio, необходимо выполнить конфигурирование, которое заключается в определении тех свойств или событий объекта View, которым сопоставляется свойство или метод ViewModel. Для связывания свойства или события View с соответствующим свойством или методом ViewModel в конфигурационном объекте View для этого свойства или события необходимо задать значение свойства `bindTo`:
* Модель представления (ViewModel)
  * ViewModel в Creatio представляет собой наследника класса `BaseViewModel`. В ней реализуется вся клиентская бизнес-логика работы системы
  * Основными свойствами ViewModel являются:
    * `values` — объект, в свойствах которого содержатся данные (поля), предоставляемые ViewModel
    * `methods` — объект, в свойствах которого содержатся методы, реализующие пользовательскую логику работы с данными ViewModel
  * При обращении к свойствам ViewModel используются методы:
    * `get(key)` — возвращает значение поля по его названию `key`
    * `set(key, value, options)` —  устанавливает значение `value` для поля с именем `key`. В метод может быть передан конфигурационный объект `options` с дополнительными параметрами
  * Запрещено обращаться к полям ViewModel  напрямую по названию. Необходимо использовать методы `get()` и `set()`, так как в данных методах реализована генерация событий изменения свойств модели и, соответственно, задействован механизм связывания

### ПРИНЦИПЫ МОДУЛЬНОЙ РАЗРАБОТКИ В CREATIO

* Для того чтобы получить доступ к функциям ядра, используемым в клиентской пользовательской логике, модуль должен импортировать в качестве зависимости модуль `terrasoft`
* Для того чтобы модуль мог взаимодействовать с другими модулями системы, он должен импортировать в качестве зависимости модуль sandbox.
* Creatio содержит модули, которые используются в большинстве клиентских модулей конфигурации. Это модуль `ext-base` функциональности фреймворка ExtJs, модуль `terrasoft` пространства имен и объектов Terrasoft и `sandbox`, реализующий механизм обмена сообщениями между модулями
  
  ``` JS
  // Определение модуля и получение ссылок на модули-зависимости.
  define("ExampleModule", ["ext-base", "terrasoft", "sandbox"], function (Ext, Terrasoft, sandbox) {
    // Ext — ссылка на объект, дающий доступ к возможностям фреймворка ExtJs
    // Terrasoft — ссылка на объект, дающий доступ к системным переменным, переменным ядра и т.д
    // sanbox — используется для обмена сообщениями между модулями
  });
  ```

### ОБЪЯВЛЕНИЕ КЛАССА МОДУЛЯ. МЕТОД EXT.DEFINE()